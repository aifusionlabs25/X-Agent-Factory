"""
Memory Pack Builder
Generates durable memory packs from CASS-indexed runs.

Usage:
    python tools/memory_builder.py --all               # Build all memory packs
    python tools/memory_builder.py --client nexgen_hvac # Build specific client
"""
import sys
sys.stdout.reconfigure(encoding='utf-8')

import os
import json
import argparse
from datetime import datetime
from pathlib import Path
from collections import defaultdict


# Configuration
PROJECT_ROOT = Path(__file__).parent.parent
RUNS_DIR = PROJECT_ROOT / "runs"
MEMORY_DIR = PROJECT_ROOT / "memory"


def ensure_memory_dirs():
    """Create memory directory structure."""
    (MEMORY_DIR / "global").mkdir(parents=True, exist_ok=True)
    (MEMORY_DIR / "clients").mkdir(parents=True, exist_ok=True)


def load_all_runs():
    """Load all run metadata from runs/ directory."""
    runs = []
    
    if not RUNS_DIR.exists():
        return runs
    
    for date_dir in RUNS_DIR.iterdir():
        if not date_dir.is_dir():
            continue
        
        for run_dir in date_dir.iterdir():
            if not run_dir.is_dir():
                continue
            
            metadata_path = run_dir / "run_metadata.json"
            if metadata_path.exists():
                try:
                    with open(metadata_path, 'r', encoding='utf-8') as f:
                        meta = json.load(f)
                        meta['_run_dir'] = str(run_dir)
                        runs.append(meta)
                except Exception as e:
                    print(f"   ‚ö†Ô∏è Error loading {metadata_path}: {e}")
    
    return runs


def get_client_slug_from_run(run):
    """Extract client_slug from run metadata."""
    # Try outputs first
    if 'outputs' in run and 'client_slug' in run['outputs']:
        return run['outputs']['client_slug']
    
    # Try args
    if 'args' in run:
        if 'dossier' in run['args']:
            # Extract from dossier path
            dossier_path = run['args']['dossier']
            parts = Path(dossier_path).parts
            for i, part in enumerate(parts):
                if part == 'ingested_clients' and i + 1 < len(parts):
                    return parts[i + 1]
                if part == 'agents' and i + 1 < len(parts):
                    return parts[i + 1]
    
    return None


def build_global_playbook(runs):
    """Build global factory playbook from all runs."""
    print("\nüìö Building global factory playbook...")
    
    # Statistics
    total_runs = len(runs)
    successful = sum(1 for r in runs if r.get('success', False))
    failed = total_runs - successful
    
    # Collect unique tools and clients
    tools_used = defaultdict(int)
    clients_seen = set()
    errors_seen = []
    
    for run in runs:
        tool = run.get('tool', 'unknown')
        tools_used[tool] += 1
        
        client = get_client_slug_from_run(run)
        if client:
            clients_seen.add(client)
        
        if run.get('errors'):
            for err in run['errors']:
                errors_seen.append({
                    'tool': tool,
                    'error': err,
                    'timestamp': run.get('timestamp', 'unknown')
                })
    
    # Generate playbook
    playbook = f"""# Factory Playbook

**Generated:** {datetime.utcnow().isoformat()}Z
**Total Runs:** {total_runs}

## Summary

| Metric | Value |
|--------|-------|
| Total Runs | {total_runs} |
| Successful | {successful} |
| Failed | {failed} |
| Success Rate | {(successful/total_runs*100) if total_runs else 0:.1f}% |
| Unique Clients | {len(clients_seen)} |

## Tools Usage

"""
    for tool, count in sorted(tools_used.items(), key=lambda x: -x[1]):
        playbook += f"- **{tool}**: {count} runs\n"
    
    playbook += "\n## Active Clients\n\n"
    for client in sorted(clients_seen):
        playbook += f"- {client}\n"
    
    if errors_seen:
        playbook += "\n## Recent Errors (Gotchas)\n\n"
        for err in errors_seen[-10:]:  # Last 10
            playbook += f"- [{err['tool']}] {err['error']}\n"
    
    playbook += "\n---\n_Auto-generated by CM Memory Builder_\n"
    
    # Save
    playbook_path = MEMORY_DIR / "global" / "factory_playbook.md"
    with open(playbook_path, 'w', encoding='utf-8') as f:
        f.write(playbook)
    print(f"   ‚úÖ {playbook_path}")
    
    return playbook_path


def build_gotchas(runs):
    """Build gotchas document from errors."""
    print("üìö Building gotchas document...")
    
    errors_by_type = defaultdict(list)
    
    for run in runs:
        if run.get('errors'):
            tool = run.get('tool', 'unknown')
            for err in run['errors']:
                errors_by_type[tool].append({
                    'error': err,
                    'timestamp': run.get('timestamp', 'unknown'),
                    'args': run.get('args', {})
                })
    
    gotchas = f"""# Factory Gotchas

**Generated:** {datetime.utcnow().isoformat()}Z

Common errors and how to handle them.

"""
    
    if not errors_by_type:
        gotchas += "_No errors recorded yet. Good job!_\n"
    else:
        for tool, errors in errors_by_type.items():
            gotchas += f"## {tool}\n\n"
            for err in errors[-5:]:  # Last 5 per tool
                gotchas += f"- **{err['error']}**\n"
                gotchas += f"  - Timestamp: {err['timestamp']}\n"
    
    gotchas += "\n---\n_Auto-generated by CM Memory Builder_\n"
    
    gotchas_path = MEMORY_DIR / "global" / "gotchas.md"
    with open(gotchas_path, 'w', encoding='utf-8') as f:
        f.write(gotchas)
    print(f"   ‚úÖ {gotchas_path}")
    
    return gotchas_path


def build_client_memory_pack(client_slug, runs):
    """Build memory pack for a specific client."""
    print(f"\nüì¶ Building memory pack for: {client_slug}")
    
    # Filter runs for this client
    client_runs = []
    for run in runs:
        slug = get_client_slug_from_run(run)
        if slug == client_slug:
            client_runs.append(run)
    
    if not client_runs:
        print(f"   ‚ö†Ô∏è No runs found for {client_slug}")
        return None
    
    # Create client directory
    client_dir = MEMORY_DIR / "clients" / client_slug
    client_dir.mkdir(parents=True, exist_ok=True)
    
    # Sort by timestamp
    client_runs.sort(key=lambda x: x.get('timestamp', ''), reverse=True)
    
    # Build memory pack
    latest = client_runs[0]
    
    memory_pack = f"""# Memory Pack: {client_slug}

**Generated:** {datetime.utcnow().isoformat()}Z
**Last Run:** {latest.get('timestamp', 'unknown')}
**Total Runs:** {len(client_runs)}

## Latest Build

- **Tool:** {latest.get('tool', 'unknown')}
- **Success:** {'‚úÖ' if latest.get('success') else '‚ùå'}
- **Duration:** {latest.get('duration_seconds', 0):.2f}s

## Outputs

"""
    outputs = latest.get('outputs', {})
    for key, value in outputs.items():
        memory_pack += f"- **{key}:** {value}\n"
    
    memory_pack += "\n## Run History\n\n"
    memory_pack += "| Date | Tool | Success | Duration |\n"
    memory_pack += "|------|------|---------|----------|\n"
    
    for run in client_runs[:10]:  # Last 10
        ts = run.get('timestamp', '')[:10]
        tool = run.get('tool', 'unknown')
        success = '‚úÖ' if run.get('success') else '‚ùå'
        duration = f"{run.get('duration_seconds', 0):.2f}s"
        memory_pack += f"| {ts} | {tool} | {success} | {duration} |\n"
    
    if latest.get('errors'):
        memory_pack += "\n## Recent Errors\n\n"
        for err in latest['errors']:
            memory_pack += f"- {err}\n"
    
    memory_pack += "\n---\n_Auto-generated by CM Memory Builder_\n"
    
    # Save memory pack
    pack_path = client_dir / "memory_pack.md"
    with open(pack_path, 'w', encoding='utf-8') as f:
        f.write(memory_pack)
    print(f"   ‚úÖ {pack_path}")
    
    # Build notes (from args)
    build_notes = f"""# Build Notes: {client_slug}

**Generated:** {datetime.utcnow().isoformat()}Z

## Configuration

"""
    args = latest.get('args', {})
    for key, value in args.items():
        build_notes += f"- **{key}:** {value}\n"
    
    notes_path = client_dir / "build_notes.md"
    with open(notes_path, 'w', encoding='utf-8') as f:
        f.write(build_notes)
    print(f"   ‚úÖ {notes_path}")
    
    return pack_path


def build_all_memory_packs():
    """Build all memory packs."""
    print(f"\n{'='*60}")
    print(f"üß† CM MEMORY BUILDER")
    print(f"   Building all memory packs...")
    print(f"{'='*60}")
    
    ensure_memory_dirs()
    
    # Load all runs
    runs = load_all_runs()
    print(f"\nüìÇ Found {len(runs)} run(s)")
    
    if not runs:
        print("   ‚ö†Ô∏è No runs found. Run some factory commands first.")
        return True
    
    # Build global artifacts
    build_global_playbook(runs)
    build_gotchas(runs)
    
    # Find unique clients
    clients = set()
    for run in runs:
        slug = get_client_slug_from_run(run)
        if slug:
            clients.add(slug)
    
    print(f"\nüë• Found {len(clients)} client(s)")
    
    # Build client packs
    for client in clients:
        build_client_memory_pack(client, runs)
    
    print(f"\n{'='*60}")
    print(f"‚úÖ MEMORY BUILD COMPLETE")
    print(f"   Output: {MEMORY_DIR}")
    print(f"{'='*60}\n")
    
    return True


def build_single_client(client_slug):
    """Build memory pack for a single client."""
    print(f"\n{'='*60}")
    print(f"üß† CM MEMORY BUILDER")
    print(f"   Building memory pack for: {client_slug}")
    print(f"{'='*60}")
    
    ensure_memory_dirs()
    
    runs = load_all_runs()
    result = build_client_memory_pack(client_slug, runs)
    
    if result:
        print(f"\n‚úÖ Memory pack built: {result}")
        return True
    else:
        print(f"\n‚ùå Failed to build memory pack for {client_slug}")
        return False


def main():
    parser = argparse.ArgumentParser(description="CM Memory Pack Builder")
    parser.add_argument("--all", action="store_true", help="Build all memory packs")
    parser.add_argument("--client", metavar="SLUG", help="Build memory pack for specific client")
    
    args = parser.parse_args()
    
    if args.client:
        success = build_single_client(args.client)
    else:
        # Default to --all
        success = build_all_memory_packs()
    
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
